!
! Copyright (C) 2006 LEPES-CNRS Grenoble
!
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
! Contributors  : Pierre DARANCET
!*********************************************
   MODULE recursion_function_module
!*********************************************
   USE parameters,      ONLY : nstrx
   USE dim_variable_module,        ONLY : dimwan, dim_subspace, dim_recursion
   USE kinds
   USE constants,            ONLY : CZERO, CONE
   USE io_global_module,     ONLY : stdin
   USE iotk_module
   USE control_variable_module,      ONLY : max_iter


   IMPLICIT NONE
   PRIVATE 
   SAVE


   COMPLEX(dbl), ALLOCATABLE ::  A_matrix_0(:,:), B_matrix_0(:,:)

   COMPLEX(dbl), ALLOCATABLE ::  A_matrix(:,:,:), B_matrix(:,:,:)

   PUBLIC :: H_recursion
!   PUBLIC :: first_iteration
   PUBLIC :: recursion_allocate
   PUBLIC :: recursion_deallocate
   PUBLIC :: initial_value
             

CONTAINS

! !*******************************************************************
!    SUBROUTINE first_iteration
!    !*******************************************************************
   !

! A_0^[i,j] = < Phi^j_0 | H | Phi^i_0 >
! | Psy'_1 >  =  H | Phi_0 >  -  A_0^[i,j] | Phi^j_0 >
! B_0 = (< Psy'_1 | Psy'_1 >)^(1/2)
! | Psy_1 > = B_0^(-1) | Psy'_1 >
! A_1 = < Psy_1 | H | Psy_1 > 
! | Psy'_2 >  =  H | Psy_1 >  -  A_1 | Psy_1 >  - B_0 | Phi_0 >
! B_1 = (< Psy'_2 | Psy'_2 >)^(1/2)
! | Psy_2 > = B_1^(-1) | Psy'_2 >
! A_2 = < Psy_2 | H | Psy_2 > 
! | Psy'_3 >  =  H | Psy_2 >  -  A_2 | Psy_2 >  - B_1 | Psy_1 >

!    CHARACTER(15) :: subname="first_iteration"
!    COMPLEX(dbl), ALLOCATABLE :: aux(:,:)
!    INTEGER       :: i, ierr
! END SUBROUTINE first_iteration


!*******************************************************************
   SUBROUTINE recursion_allocate
   !*******************************************************************
      CHARACTER(30)      :: subname="recursion_hamiltonian_allocate"
      INTEGER :: ierr


    dimwan
    dim_subspace
    dim_recursion




    ! Allocate A-type matrices
   ALLOCATE ( A_matrix_0(dim_subpace,dim_subpace), STAT=ierr )
        IF( ierr /=0 ) CALL errore(subname, 'allocating A_matrix_0', ABS(ierr) )
   ALLOCATE ( A_matrix(max_iter,dim_subpace,dim_subpace), STAT=ierr )
        IF( ierr /=0 ) CALL errore(subname, 'allocating A_matrix', ABS(ierr) )
    ! Allocate B-type matrices
   ALLOCATE ( B_matrix_0(dim_subpace,dim_subpace), STAT=ierr )
        IF( ierr /=0 ) CALL errore(subname, 'allocating B_matrix_0', ABS(ierr) )
   ALLOCATE ( B_matrix(max_iter,dim_subpace,dim_subpace), STAT=ierr )
        IF( ierr /=0 ) CALL errore(subname, 'allocating B_matrix', ABS(ierr) )
    ! Allocate Wave functions
   


END SUBROUTINE recursion_allocate

!**********************************************************
   SUBROUTINE recursion_deallocate()
   !**********************************************************
   IMPLICIT NONE
      CHARACTER(32)      :: subname="recursion_hamiltonian_deallocate"
      INTEGER :: ierr

     IF ( ALLOCATED( A_matrix_0  ) ) THEN
           DEALLOCATE ( A_matrix_0, STAT=ierr )
           IF( ierr /=0 ) CALL errore(subname, 'deallocating A_matrix_0', ABS(ierr) )
      ENDIF
     IF ( ALLOCATED( A_matrix  ) ) THEN
           DEALLOCATE ( A_matrix , STAT=ierr )
           IF( ierr /=0 ) CALL errore(subname, 'deallocating A_matrix', ABS(ierr) )
      ENDIF
     IF ( ALLOCATED( B_matrix_0  ) ) THEN
           DEALLOCATE ( B_matrix_0, STAT=ierr )
           IF( ierr /=0 ) CALL errore(subname, 'deallocating B_matrix_0', ABS(ierr) )
      ENDIF
     IF ( ALLOCATED( B_matrix  ) ) THEN
           DEALLOCATE ( B_matrix , STAT=ierr )
           IF( ierr /=0 ) CALL errore(subname, 'deallocating B_matrix', ABS(ierr) )
      ENDIF


   END SUBROUTINE recursion_deallocate

!**********************************************************
   SUBROUTINE initial_value()
   !**********************************************************
   IMPLICIT NONE
      CHARACTER(32)      :: subname=""
      INTEGER :: ierr

A_matrix_0(:,:)=CZERO
A_matrix(:,:,:)=
B_matrix_0(:,:)=
B_matrix(:,:,:)=

   END SUBROUTINE initial_value


!*******************************************************************
   SUBROUTINE print_hamiltonian
   !*******************************************************************
      CHARACTER(17)      :: subname="print_hamiltonian"
      INTEGER :: ierr

END SUBROUTINE print_hamiltonian

END MODULE recursion_function_module


